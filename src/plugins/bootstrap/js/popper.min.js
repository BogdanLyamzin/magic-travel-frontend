/*
 Copyright (C) Federico Zivolo 2018
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */ (function (
  e,
  t,
) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? (module.exports = t())
    : typeof define === 'function' && define.amd
    ? define(t)
    : (e.Popper = t());
})(this, function () {
  function e(e) {
    return e && {}.toString.call(e) === '[object Function]';
  }

  function t(e, t) {
    if (e.nodeType !== 1) return [];
    const o = getComputedStyle(e, null);
    return t ? o[t] : o;
  }
  function o(e) {
    return e.nodeName === 'HTML' ? e : e.parentNode || e.host;
  }
  function n(e) {
    if (!e) return document.body;
    switch (e.nodeName) {
      case 'HTML':
      case 'BODY':
        return e.ownerDocument.body;
      case '#document':
        return e.body;
    }
    const i = t(e);
    const r = i.overflow;
    const p = i.overflowX;
    const s = i.overflowY;
    return /(auto|scroll|overlay)/.test(r + s + p) ? e : n(o(e));
  }
  function r(e) {
    if (!e) return document.documentElement;
    for (
      var o = ie(10) ? document.body : null, n = e.offsetParent;
      n === o && e.nextElementSibling;

    )
      n = (e = e.nextElementSibling).offsetParent;
    const i = n && n.nodeName;
    return i && i !== 'BODY' && i !== 'HTML'
      ? ['TD', 'TABLE'].indexOf(n.nodeName) !== -1 &&
        t(n, 'position') === 'static'
        ? r(n)
        : n
      : e
      ? e.ownerDocument.documentElement
      : document.documentElement;
  }
  function p(e) {
    const t = e.nodeName;
    return t !== 'BODY' && (t === 'HTML' || r(e.firstElementChild) === e);
  }
  function s(e) {
    return e.parentNode === null ? e : s(e.parentNode);
  }
  function d(e, t) {
    if (!e || !e.nodeType || !t || !t.nodeType) return document.documentElement;
    const o = e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_FOLLOWING;
    const n = o ? e : t;
    const i = o ? t : e;
    const a = document.createRange();
    a.setStart(n, 0), a.setEnd(i, 0);
    const l = a.commonAncestorContainer;
    if ((e !== l && t !== l) || n.contains(i)) return p(l) ? l : r(l);
    const f = s(e);
    return f.host ? d(f.host, t) : d(e, s(t).host);
  }
  function a(e) {
    const t =
      arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'top';
    const o = t === 'top' ? 'scrollTop' : 'scrollLeft';
    const n = e.nodeName;
    if (n === 'BODY' || n === 'HTML') {
      const i = e.ownerDocument.documentElement;
      const r = e.ownerDocument.scrollingElement || i;
      return r[o];
    }
    return e[o];
  }
  function l(e, t) {
    const o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    const n = a(t, 'top');
    const i = a(t, 'left');
    const r = o ? -1 : 1;
    return (
      (e.top += n * r),
      (e.bottom += n * r),
      (e.left += i * r),
      (e.right += i * r),
      e
    );
  }
  function f(e, t) {
    const o = t === 'x' ? 'Left' : 'Top';
    const n = o == 'Left' ? 'Right' : 'Bottom';
    return (
      parseFloat(e[`border${o}Width`], 10) +
      parseFloat(e[`border${n}Width`], 10)
    );
  }
  function m(e, t, o, n) {
    return Q(
      t[`offset${e}`],
      t[`scroll${e}`],
      o[`client${e}`],
      o[`offset${e}`],
      o[`scroll${e}`],
      ie(10)
        ? o[`offset${e}`] +
            n[`margin${e === 'Height' ? 'Top' : 'Left'}`] +
            n[`margin${e === 'Height' ? 'Bottom' : 'Right'}`]
        : 0,
    );
  }
  function h() {
    const e = document.body;
    const t = document.documentElement;
    const o = ie(10) && getComputedStyle(t);
    return { height: m('Height', e, t, o), width: m('Width', e, t, o) };
  }
  function c(e) {
    return { ...e, right: e.left + e.width, bottom: e.top + e.height };
  }
  function g(e) {
    let o = {};
    try {
      if (ie(10)) {
        o = e.getBoundingClientRect();
        const n = a(e, 'top');
        const i = a(e, 'left');
        (o.top += n), (o.left += i), (o.bottom += n), (o.right += i);
      } else o = e.getBoundingClientRect();
    } catch (t) {}
    const r = {
      left: o.left,
      top: o.top,
      width: o.right - o.left,
      height: o.bottom - o.top,
    };
    const p = e.nodeName === 'HTML' ? h() : {};
    const s = p.width || e.clientWidth || r.right - r.left;
    const d = p.height || e.clientHeight || r.bottom - r.top;
    let l = e.offsetWidth - s;
    let m = e.offsetHeight - d;
    if (l || m) {
      const g = t(e);
      (l -= f(g, 'x')), (m -= f(g, 'y')), (r.width -= l), (r.height -= m);
    }
    return c(r);
  }
  function u(e, o) {
    const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    const r = ie(10);
    const p = o.nodeName === 'HTML';
    const s = g(e);
    const d = g(o);
    const a = n(e);
    const f = t(o);
    const m = parseFloat(f.borderTopWidth, 10);
    const h = parseFloat(f.borderLeftWidth, 10);
    i &&
      o.nodeName === 'HTML' &&
      ((d.top = Q(d.top, 0)), (d.left = Q(d.left, 0)));
    let u = c({
      top: s.top - d.top - m,
      left: s.left - d.left - h,
      width: s.width,
      height: s.height,
    });
    if (((u.marginTop = 0), (u.marginLeft = 0), !r && p)) {
      const b = parseFloat(f.marginTop, 10);
      const y = parseFloat(f.marginLeft, 10);
      (u.top -= m - b),
        (u.bottom -= m - b),
        (u.left -= h - y),
        (u.right -= h - y),
        (u.marginTop = b),
        (u.marginLeft = y);
    }
    return (
      (r && !i ? o.contains(a) : o === a && a.nodeName !== 'BODY') &&
        (u = l(u, o)),
      u
    );
  }
  function b(e) {
    const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    const o = e.ownerDocument.documentElement;
    const n = u(e, o);
    const i = Q(o.clientWidth, window.innerWidth || 0);
    const r = Q(o.clientHeight, window.innerHeight || 0);
    const p = t ? 0 : a(o);
    const s = t ? 0 : a(o, 'left');
    const d = {
      top: p - n.top + n.marginTop,
      left: s - n.left + n.marginLeft,
      width: i,
      height: r,
    };
    return c(d);
  }
  function y(e) {
    const n = e.nodeName;
    return n === 'BODY' || n === 'HTML'
      ? !1
      : t(e, 'position') === 'fixed' || y(o(e));
  }
  function w(e) {
    if (!e || !e.parentElement || ie()) return document.documentElement;
    for (var o = e.parentElement; o && t(o, 'transform') === 'none'; )
      o = o.parentElement;
    return o || document.documentElement;
  }
  function E(e, t, i, r) {
    const p = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    let s = { top: 0, left: 0 };
    const a = p ? w(e) : d(e, t);
    if (r === 'viewport') s = b(a, p);
    else {
      let l;
      r === 'scrollParent'
        ? ((l = n(o(t))),
          l.nodeName === 'BODY' && (l = e.ownerDocument.documentElement))
        : r === 'window'
        ? (l = e.ownerDocument.documentElement)
        : (l = r);
      const f = u(l, a, p);
      if (l.nodeName === 'HTML' && !y(a)) {
        const m = h();
        const c = m.height;
        const g = m.width;
        (s.top += f.top - f.marginTop),
          (s.bottom = c + f.top),
          (s.left += f.left - f.marginLeft),
          (s.right = g + f.left);
      } else s = f;
    }
    return (s.left += i), (s.top += i), (s.right -= i), (s.bottom -= i), s;
  }
  function v(e) {
    const t = e.width;
    const o = e.height;
    return t * o;
  }
  function x(e, t, o, n, i) {
    const r =
      arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
    if (e.indexOf('auto') === -1) return e;
    const p = E(o, n, r, i);
    const s = {
      top: { width: p.width, height: t.top - p.top },
      right: { width: p.right - t.right, height: p.height },
      bottom: { width: p.width, height: p.bottom - t.bottom },
      left: { width: t.left - p.left, height: p.height },
    };
    const d = Object.keys(s)
      .map(function (e) {
        return { key: e, ...s[e], area: v(s[e]) };
      })
      .sort(function (e, t) {
        return t.area - e.area;
      });
    const a = d.filter(function (e) {
      const t = e.width;
      const n = e.height;
      return t >= o.clientWidth && n >= o.clientHeight;
    });
    const l = a.length > 0 ? a[0].key : d[0].key;
    const f = e.split('-')[1];
    return l + (f ? `-${f}` : '');
  }
  function O(e, t, o) {
    const n =
      arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    const i = n ? w(t) : d(t, o);
    return u(o, i, n);
  }
  function L(e) {
    const t = getComputedStyle(e);
    const o = parseFloat(t.marginTop) + parseFloat(t.marginBottom);
    const n = parseFloat(t.marginLeft) + parseFloat(t.marginRight);
    const i = { width: e.offsetWidth + n, height: e.offsetHeight + o };
    return i;
  }
  function S(e) {
    const t = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
    return e.replace(/left|right|bottom|top/g, function (e) {
      return t[e];
    });
  }
  function T(e, t, o) {
    o = o.split('-')[0];
    const n = L(e);
    const i = { width: n.width, height: n.height };
    const r = ['right', 'left'].indexOf(o) !== -1;
    const p = r ? 'top' : 'left';
    const s = r ? 'left' : 'top';
    const d = r ? 'height' : 'width';
    const a = r ? 'width' : 'height';
    return (
      (i[p] = t[p] + t[d] / 2 - n[d] / 2),
      (i[s] = o === s ? t[s] - n[a] : t[S(s)]),
      i
    );
  }
  function D(e, t) {
    return Array.prototype.find ? e.find(t) : e.filter(t)[0];
  }
  function C(e, t, o) {
    if (Array.prototype.findIndex)
      return e.findIndex(function (e) {
        return e[t] === o;
      });
    const n = D(e, function (e) {
      return e[t] === o;
    });
    return e.indexOf(n);
  }
  function N(t, o, n) {
    const i = void 0 === n ? t : t.slice(0, C(t, 'name', n));
    return (
      i.forEach(function (t) {
        t.function &&
          console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
        const n = t.function || t.fn;
        t.enabled &&
          e(n) &&
          ((o.offsets.popper = c(o.offsets.popper)),
          (o.offsets.reference = c(o.offsets.reference)),
          (o = n(o, t)));
      }),
      o
    );
  }
  function k() {
    if (!this.state.isDestroyed) {
      let e = {
        instance: this,
        styles: {},
        arrowStyles: {},
        attributes: {},
        flipped: !1,
        offsets: {},
      };
      (e.offsets.reference = O(
        this.state,
        this.popper,
        this.reference,
        this.options.positionFixed,
      )),
        (e.placement = x(
          this.options.placement,
          e.offsets.reference,
          this.popper,
          this.reference,
          this.options.modifiers.flip.boundariesElement,
          this.options.modifiers.flip.padding,
        )),
        (e.originalPlacement = e.placement),
        (e.positionFixed = this.options.positionFixed),
        (e.offsets.popper = T(this.popper, e.offsets.reference, e.placement)),
        (e.offsets.popper.position = this.options.positionFixed
          ? 'fixed'
          : 'absolute'),
        (e = N(this.modifiers, e)),
        this.state.isCreated
          ? this.options.onUpdate(e)
          : ((this.state.isCreated = !0), this.options.onCreate(e));
    }
  }
  function P(e, t) {
    return e.some(function (e) {
      const o = e.name;
      const n = e.enabled;
      return n && o === t;
    });
  }
  function W(e) {
    for (
      let t = [!1, 'ms', 'Webkit', 'Moz', 'O'],
        o = e.charAt(0).toUpperCase() + e.slice(1),
        n = 0;
      n < t.length;
      n++
    ) {
      const i = t[n];
      const r = i ? `${i}${o}` : e;
      if (typeof document.body.style[r] !== 'undefined') return r;
    }
    return null;
  }
  function B() {
    return (
      (this.state.isDestroyed = !0),
      P(this.modifiers, 'applyStyle') &&
        (this.popper.removeAttribute('x-placement'),
        (this.popper.style.position = ''),
        (this.popper.style.top = ''),
        (this.popper.style.left = ''),
        (this.popper.style.right = ''),
        (this.popper.style.bottom = ''),
        (this.popper.style.willChange = ''),
        (this.popper.style[W('transform')] = '')),
      this.disableEventListeners(),
      this.options.removeOnDestroy &&
        this.popper.parentNode.removeChild(this.popper),
      this
    );
  }
  function H(e) {
    const t = e.ownerDocument;
    return t ? t.defaultView : window;
  }
  function A(e, t, o, i) {
    const r = e.nodeName === 'BODY';
    const p = r ? e.ownerDocument.defaultView : e;
    p.addEventListener(t, o, { passive: !0 }),
      r || A(n(p.parentNode), t, o, i),
      i.push(p);
  }
  function I(e, t, o, i) {
    (o.updateBound = i),
      H(e).addEventListener('resize', o.updateBound, { passive: !0 });
    const r = n(e);
    return (
      A(r, 'scroll', o.updateBound, o.scrollParents),
      (o.scrollElement = r),
      (o.eventsEnabled = !0),
      o
    );
  }
  function M() {
    this.state.eventsEnabled ||
      (this.state = I(
        this.reference,
        this.options,
        this.state,
        this.scheduleUpdate,
      ));
  }
  function F(e, t) {
    return (
      H(e).removeEventListener('resize', t.updateBound),
      t.scrollParents.forEach(function (e) {
        e.removeEventListener('scroll', t.updateBound);
      }),
      (t.updateBound = null),
      (t.scrollParents = []),
      (t.scrollElement = null),
      (t.eventsEnabled = !1),
      t
    );
  }
  function R() {
    this.state.eventsEnabled &&
      (cancelAnimationFrame(this.scheduleUpdate),
      (this.state = F(this.reference, this.state)));
  }
  function U(e) {
    return e !== '' && !isNaN(parseFloat(e)) && isFinite(e);
  }
  function Y(e, t) {
    Object.keys(t).forEach(function (o) {
      let n = '';
      ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(o) !== -1 &&
        U(t[o]) &&
        (n = 'px'),
        (e.style[o] = t[o] + n);
    });
  }
  function j(e, t) {
    Object.keys(t).forEach(function (o) {
      const n = t[o];
      !1 === n ? e.removeAttribute(o) : e.setAttribute(o, t[o]);
    });
  }
  function q(e, t, o) {
    const n = D(e, function (e) {
      const o = e.name;
      return o === t;
    });
    const i =
      !!n &&
      e.some(function (e) {
        return e.name === o && e.enabled && e.order < n.order;
      });
    if (!i) {
      const r = `\`${t}\``;
      console.warn(
        `\`${o}\`` +
          ` modifier is required by ${r} modifier in order to work, be sure to include it before ${r}!`,
      );
    }
    return i;
  }
  function K(e) {
    return e === 'end' ? 'start' : e === 'start' ? 'end' : e;
  }
  function V(e) {
    const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    const o = le.indexOf(e);
    const n = le.slice(o + 1).concat(le.slice(0, o));
    return t ? n.reverse() : n;
  }
  function z(e, t, o, n) {
    const i = e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    const r = +i[1];
    const p = i[2];
    if (!r) return e;
    if (p.indexOf('%') === 0) {
      let s;
      switch (p) {
        case '%p':
          s = o;
          break;
        case '%':
        case '%r':
        default:
          s = n;
      }
      const d = c(s);
      return (d[t] / 100) * r;
    }
    if (p === 'vh' || p === 'vw') {
      let a;
      return (
        (a =
          p === 'vh'
            ? Q(document.documentElement.clientHeight, window.innerHeight || 0)
            : Q(document.documentElement.clientWidth, window.innerWidth || 0)),
        (a / 100) * r
      );
    }
    return r;
  }
  function G(e, t, o, n) {
    const i = [0, 0];
    const r = ['right', 'left'].indexOf(n) !== -1;
    const p = e.split(/(\+|\-)/).map(function (e) {
      return e.trim();
    });
    const s = p.indexOf(
      D(p, function (e) {
        return e.search(/,|\s/) !== -1;
      }),
    );
    p[s] &&
      p[s].indexOf(',') === -1 &&
      console.warn(
        'Offsets separated by white space(s) are deprecated, use a comma (,) instead.',
      );
    const d = /\s*,\s*|\s+/;
    let a =
      s === -1
        ? [p]
        : [
            p.slice(0, s).concat([p[s].split(d)[0]]),
            [p[s].split(d)[1]].concat(p.slice(s + 1)),
          ];
    return (
      (a = a.map(function (e, n) {
        const i = (n === 1 ? !r : r) ? 'height' : 'width';
        let p = !1;
        return e
          .reduce(function (e, t) {
            return e[e.length - 1] === '' && ['+', '-'].indexOf(t) !== -1
              ? ((e[e.length - 1] = t), (p = !0), e)
              : p
              ? ((e[e.length - 1] += t), (p = !1), e)
              : e.concat(t);
          }, [])
          .map(function (e) {
            return z(e, i, t, o);
          });
      })),
      a.forEach(function (e, t) {
        e.forEach(function (o, n) {
          U(o) && (i[t] += o * (e[n - 1] === '-' ? -1 : 1));
        });
      }),
      i
    );
  }
  function _(e, t) {
    let o;
    const n = t.offset;
    const i = e.placement;
    const r = e.offsets;
    const p = r.popper;
    const s = r.reference;
    const d = i.split('-')[0];
    return (
      (o = U(+n) ? [+n, 0] : G(n, p, s, d)),
      d === 'left'
        ? ((p.top += o[0]), (p.left -= o[1]))
        : d === 'right'
        ? ((p.top += o[0]), (p.left += o[1]))
        : d === 'top'
        ? ((p.left += o[0]), (p.top -= o[1]))
        : d === 'bottom' && ((p.left += o[0]), (p.top += o[1])),
      (e.popper = p),
      e
    );
  }
  for (
    var X = Math.min,
      J = Math.floor,
      Q = Math.max,
      Z = typeof window !== 'undefined' && typeof document !== 'undefined',
      $ = ['Edge', 'Trident', 'Firefox'],
      ee = 0,
      te = 0;
    te < $.length;
    te += 1
  )
    if (Z && navigator.userAgent.indexOf($[te]) >= 0) {
      ee = 1;
      break;
    }
  const i = Z && window.Promise;
  const oe = i
    ? function (e) {
        let t = !1;
        return function () {
          t ||
            ((t = !0),
            window.Promise.resolve().then(function () {
              (t = !1), e();
            }));
        };
      }
    : function (e) {
        let t = !1;
        return function () {
          t ||
            ((t = !0),
            setTimeout(function () {
              (t = !1), e();
            }, ee));
        };
      };
  const ne = {};
  var ie = function () {
    let e =
      arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 'all';
    return ((e = e.toString()), ne.hasOwnProperty(e))
      ? ne[e]
      : (e === '11'
          ? (ne[e] = navigator.userAgent.indexOf('Trident') !== -1)
          : e === '10'
          ? (ne[e] = navigator.appVersion.indexOf('MSIE 10') !== -1)
          : e === 'all'
          ? (ne[e] =
              navigator.userAgent.indexOf('Trident') !== -1 ||
              navigator.userAgent.indexOf('MSIE') !== -1)
          : void 0,
        (ne.all =
          ne.all ||
          Object.keys(ne).some(function (e) {
            return ne[e];
          })),
        ne[e]);
  };
  const re = function (e, t) {
    if (!(e instanceof t))
      throw new TypeError('Cannot call a class as a function');
  };
  const pe = (function () {
    function e(e, t) {
      for (var o, n = 0; n < t.length; n++)
        (o = t[n]),
          (o.enumerable = o.enumerable || !1),
          (o.configurable = !0),
          'value' in o && (o.writable = !0),
          Object.defineProperty(e, o.key, o);
    }
    return function (t, o, n) {
      return o && e(t.prototype, o), n && e(t, n), t;
    };
  })();
  const se = function (e, t, o) {
    return (
      t in e
        ? Object.defineProperty(e, t, {
            value: o,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (e[t] = o),
      e
    );
  };
  const de =
    Object.assign ||
    function (e) {
      for (var t, o = 1; o < arguments.length; o++)
        for (const n in ((t = arguments[o]), t))
          Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
      return e;
    };
  const ae = [
    'auto-start',
    'auto',
    'auto-end',
    'top-start',
    'top',
    'top-end',
    'right-start',
    'right',
    'right-end',
    'bottom-end',
    'bottom',
    'bottom-start',
    'left-end',
    'left',
    'left-start',
  ];
  var le = ae.slice(3);
  const fe = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise',
  };
  const me = (function () {
    function t(o, n) {
      const i = this;
      const r =
        arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      re(this, t),
        (this.scheduleUpdate = function () {
          return requestAnimationFrame(i.update);
        }),
        (this.update = oe(this.update.bind(this))),
        (this.options = { ...t.Defaults, ...r }),
        (this.state = { isDestroyed: !1, isCreated: !1, scrollParents: [] }),
        (this.reference = o && o.jquery ? o[0] : o),
        (this.popper = n && n.jquery ? n[0] : n),
        (this.options.modifiers = {}),
        Object.keys({ ...t.Defaults.modifiers, ...r.modifiers }).forEach(
          function (e) {
            i.options.modifiers[e] = {
              ...(t.Defaults.modifiers[e] || {}),
              ...(r.modifiers ? r.modifiers[e] : {}),
            };
          },
        ),
        (this.modifiers = Object.keys(this.options.modifiers)
          .map(function (e) {
            return { name: e, ...i.options.modifiers[e] };
          })
          .sort(function (e, t) {
            return e.order - t.order;
          })),
        this.modifiers.forEach(function (t) {
          t.enabled &&
            e(t.onLoad) &&
            t.onLoad(i.reference, i.popper, i.options, t, i.state);
        }),
        this.update();
      const p = this.options.eventsEnabled;
      p && this.enableEventListeners(), (this.state.eventsEnabled = p);
    }
    return (
      pe(t, [
        {
          key: 'update',
          value() {
            return k.call(this);
          },
        },
        {
          key: 'destroy',
          value() {
            return B.call(this);
          },
        },
        {
          key: 'enableEventListeners',
          value() {
            return M.call(this);
          },
        },
        {
          key: 'disableEventListeners',
          value() {
            return R.call(this);
          },
        },
      ]),
      t
    );
  })();
  return (
    (me.Utils = (typeof window === 'undefined' ? global : window).PopperUtils),
    (me.placements = ae),
    (me.Defaults = {
      placement: 'bottom',
      positionFixed: !1,
      eventsEnabled: !0,
      removeOnDestroy: !1,
      onCreate() {},
      onUpdate() {},
      modifiers: {
        shift: {
          order: 100,
          enabled: !0,
          fn(e) {
            const t = e.placement;
            const o = t.split('-')[0];
            const n = t.split('-')[1];
            if (n) {
              const i = e.offsets;
              const r = i.reference;
              const p = i.popper;
              const s = ['bottom', 'top'].indexOf(o) !== -1;
              const d = s ? 'left' : 'top';
              const a = s ? 'width' : 'height';
              const l = {
                start: se({}, d, r[d]),
                end: se({}, d, r[d] + r[a] - p[a]),
              };
              e.offsets.popper = { ...p, ...l[n] };
            }
            return e;
          },
        },
        offset: { order: 200, enabled: !0, fn: _, offset: 0 },
        preventOverflow: {
          order: 300,
          enabled: !0,
          fn(e, t) {
            let o = t.boundariesElement || r(e.instance.popper);
            e.instance.reference === o && (o = r(o));
            const n = E(
              e.instance.popper,
              e.instance.reference,
              t.padding,
              o,
              e.positionFixed,
            );
            t.boundaries = n;
            const i = t.priority;
            let p = e.offsets.popper;
            const s = {
              primary(e) {
                let o = p[e];
                return (
                  p[e] < n[e] && !t.escapeWithReference && (o = Q(p[e], n[e])),
                  se({}, e, o)
                );
              },
              secondary(e) {
                const o = e === 'right' ? 'left' : 'top';
                let i = p[o];
                return (
                  p[e] > n[e] &&
                    !t.escapeWithReference &&
                    (i = X(p[o], n[e] - (e === 'right' ? p.width : p.height))),
                  se({}, o, i)
                );
              },
            };
            return (
              i.forEach(function (e) {
                const t =
                  ['left', 'top'].indexOf(e) === -1 ? 'secondary' : 'primary';
                p = { ...p, ...s[t](e) };
              }),
              (e.offsets.popper = p),
              e
            );
          },
          priority: ['left', 'right', 'top', 'bottom'],
          padding: 5,
          boundariesElement: 'scrollParent',
        },
        keepTogether: {
          order: 400,
          enabled: !0,
          fn(e) {
            const t = e.offsets;
            const o = t.popper;
            const n = t.reference;
            const i = e.placement.split('-')[0];
            const r = J;
            const p = ['top', 'bottom'].indexOf(i) !== -1;
            const s = p ? 'right' : 'bottom';
            const d = p ? 'left' : 'top';
            const a = p ? 'width' : 'height';
            return (
              o[s] < r(n[d]) && (e.offsets.popper[d] = r(n[d]) - o[a]),
              o[d] > r(n[s]) && (e.offsets.popper[d] = r(n[s])),
              e
            );
          },
        },
        arrow: {
          order: 500,
          enabled: !0,
          fn(e, o) {
            let n;
            if (!q(e.instance.modifiers, 'arrow', 'keepTogether')) return e;
            let i = o.element;
            if (typeof i === 'string') {
              if (((i = e.instance.popper.querySelector(i)), !i)) return e;
            } else if (!e.instance.popper.contains(i))
              return (
                console.warn(
                  'WARNING: `arrow.element` must be child of its popper element!',
                ),
                e
              );
            const r = e.placement.split('-')[0];
            const p = e.offsets;
            const s = p.popper;
            const d = p.reference;
            const a = ['left', 'right'].indexOf(r) !== -1;
            const l = a ? 'height' : 'width';
            const f = a ? 'Top' : 'Left';
            const m = f.toLowerCase();
            const h = a ? 'left' : 'top';
            const g = a ? 'bottom' : 'right';
            const u = L(i)[l];
            d[g] - u < s[m] && (e.offsets.popper[m] -= s[m] - (d[g] - u)),
              d[m] + u > s[g] && (e.offsets.popper[m] += d[m] + u - s[g]),
              (e.offsets.popper = c(e.offsets.popper));
            const b = d[m] + d[l] / 2 - u / 2;
            const y = t(e.instance.popper);
            const w = parseFloat(y[`margin${f}`], 10);
            const E = parseFloat(y[`border${f}Width`], 10);
            let v = b - e.offsets.popper[m] - w - E;
            return (
              (v = Q(X(s[l] - u, v), 0)),
              (e.arrowElement = i),
              (e.offsets.arrow =
                ((n = {}), se(n, m, Math.round(v)), se(n, h, ''), n)),
              e
            );
          },
          element: '[x-arrow]',
        },
        flip: {
          order: 600,
          enabled: !0,
          fn(e, t) {
            if (P(e.instance.modifiers, 'inner')) return e;
            if (e.flipped && e.placement === e.originalPlacement) return e;
            const o = E(
              e.instance.popper,
              e.instance.reference,
              t.padding,
              t.boundariesElement,
              e.positionFixed,
            );
            let n = e.placement.split('-')[0];
            let i = S(n);
            let r = e.placement.split('-')[1] || '';
            let p = [];
            switch (t.behavior) {
              case fe.FLIP:
                p = [n, i];
                break;
              case fe.CLOCKWISE:
                p = V(n);
                break;
              case fe.COUNTERCLOCKWISE:
                p = V(n, !0);
                break;
              default:
                p = t.behavior;
            }
            return (
              p.forEach(function (s, d) {
                if (n !== s || p.length === d + 1) return e;
                (n = e.placement.split('-')[0]), (i = S(n));
                const a = e.offsets.popper;
                const l = e.offsets.reference;
                const f = J;
                const m =
                  (n === 'left' && f(a.right) > f(l.left)) ||
                  (n === 'right' && f(a.left) < f(l.right)) ||
                  (n === 'top' && f(a.bottom) > f(l.top)) ||
                  (n === 'bottom' && f(a.top) < f(l.bottom));
                const h = f(a.left) < f(o.left);
                const c = f(a.right) > f(o.right);
                const g = f(a.top) < f(o.top);
                const u = f(a.bottom) > f(o.bottom);
                const b =
                  (n === 'left' && h) ||
                  (n === 'right' && c) ||
                  (n === 'top' && g) ||
                  (n === 'bottom' && u);
                const y = ['top', 'bottom'].indexOf(n) !== -1;
                const w =
                  !!t.flipVariations &&
                  ((y && r === 'start' && h) ||
                    (y && r === 'end' && c) ||
                    (!y && r === 'start' && g) ||
                    (!y && r === 'end' && u));
                (m || b || w) &&
                  ((e.flipped = !0),
                  (m || b) && (n = p[d + 1]),
                  w && (r = K(r)),
                  (e.placement = n + (r ? `-${r}` : '')),
                  (e.offsets.popper = {
                    ...e.offsets.popper,
                    ...T(e.instance.popper, e.offsets.reference, e.placement),
                  }),
                  (e = N(e.instance.modifiers, e, 'flip')));
              }),
              e
            );
          },
          behavior: 'flip',
          padding: 5,
          boundariesElement: 'viewport',
        },
        inner: {
          order: 700,
          enabled: !1,
          fn(e) {
            const t = e.placement;
            const o = t.split('-')[0];
            const n = e.offsets;
            const i = n.popper;
            const r = n.reference;
            const p = ['left', 'right'].indexOf(o) !== -1;
            const s = ['top', 'left'].indexOf(o) === -1;
            return (
              (i[p ? 'left' : 'top'] =
                r[o] - (s ? i[p ? 'width' : 'height'] : 0)),
              (e.placement = S(t)),
              (e.offsets.popper = c(i)),
              e
            );
          },
        },
        hide: {
          order: 800,
          enabled: !0,
          fn(e) {
            if (!q(e.instance.modifiers, 'hide', 'preventOverflow')) return e;
            const t = e.offsets.reference;
            const o = D(e.instance.modifiers, function (e) {
              return e.name === 'preventOverflow';
            }).boundaries;
            if (
              t.bottom < o.top ||
              t.left > o.right ||
              t.top > o.bottom ||
              t.right < o.left
            ) {
              if (!0 === e.hide) return e;
              (e.hide = !0), (e.attributes['x-out-of-boundaries'] = '');
            } else {
              if (!1 === e.hide) return e;
              (e.hide = !1), (e.attributes['x-out-of-boundaries'] = !1);
            }
            return e;
          },
        },
        computeStyle: {
          order: 850,
          enabled: !0,
          fn(e, t) {
            const o = t.x;
            const n = t.y;
            const i = e.offsets.popper;
            const p = D(e.instance.modifiers, function (e) {
              return e.name === 'applyStyle';
            }).gpuAcceleration;
            void 0 !== p &&
              console.warn(
                'WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!',
              );
            let s;
            let d;
            const a = void 0 === p ? t.gpuAcceleration : p;
            const l = r(e.instance.popper);
            const f = g(l);
            const m = { position: i.position };
            const h = {
              left: J(i.left),
              top: J(i.top),
              bottom: J(i.bottom),
              right: J(i.right),
            };
            const c = o === 'bottom' ? 'top' : 'bottom';
            const u = n === 'right' ? 'left' : 'right';
            const b = W('transform');
            if (
              ((d = c == 'bottom' ? -f.height + h.bottom : h.top),
              (s = u == 'right' ? -f.width + h.right : h.left),
              a && b)
            )
              (m[b] = `translate3d(${s}px, ${d}px, 0)`),
                (m[c] = 0),
                (m[u] = 0),
                (m.willChange = 'transform');
            else {
              const y = c == 'bottom' ? -1 : 1;
              const w = u == 'right' ? -1 : 1;
              (m[c] = d * y), (m[u] = s * w), (m.willChange = `${c}, ${u}`);
            }
            const E = { 'x-placement': e.placement };
            return (
              (e.attributes = { ...E, ...e.attributes }),
              (e.styles = { ...m, ...e.styles }),
              (e.arrowStyles = { ...e.offsets.arrow, ...e.arrowStyles }),
              e
            );
          },
          gpuAcceleration: !0,
          x: 'bottom',
          y: 'right',
        },
        applyStyle: {
          order: 900,
          enabled: !0,
          fn(e) {
            return (
              Y(e.instance.popper, e.styles),
              j(e.instance.popper, e.attributes),
              e.arrowElement &&
                Object.keys(e.arrowStyles).length &&
                Y(e.arrowElement, e.arrowStyles),
              e
            );
          },
          onLoad(e, t, o, n, i) {
            const r = O(i, t, e, o.positionFixed);
            const p = x(
              o.placement,
              r,
              t,
              e,
              o.modifiers.flip.boundariesElement,
              o.modifiers.flip.padding,
            );
            return (
              t.setAttribute('x-placement', p),
              Y(t, { position: o.positionFixed ? 'fixed' : 'absolute' }),
              o
            );
          },
          gpuAcceleration: void 0,
        },
      },
    }),
    me
  );
});
// # sourceMappingURL=popper.min.js.map
